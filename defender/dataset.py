import argparse
import pickle
import random
from pathlib import Path
from typing import List, Dict, Tuple, Union, Optional
import os
import numpy as np
import torch
import pathlib
from torch.utils.data import random_split
import pandas as pd
import glob
from scipy.sparse import csr_matrix

from defender.models.feature_extractor import FeatureExtractor, Features
from defender.utils import save_pickle, split_arrays


class DikePEDataset:
    def __init__(
        self,
        data_path = 'data/DikeDataset',
        use_windows = True,
        use_programs = True,
        extra_malware = ['data/malware'],
        extra_benign = None,
        feature_extractors: List[Features] = None,
        train_ratio=0.8,
        save_splits='data',
        seed:int = 123456,
        train_test_extractor=False,
    ):
        """
        Args:
            data_path (str, optional): path of the Dike dataset. None if not used. Defaults to 'data/DikeDataset'.
            use_windows (bool, optional): whether to include windows system files. Defaults to True.
            use_programs (bool, optional): whether to include program files. Defaults to True.
            extra_malware (list, optional): list of malware folders to include. Defaults to ['data/malware'].
            extra_benign (_type_, optional): list of benign folders to include. Defaults to None.
            feature_extractors (List[Features], optional): list of feature extractors to use. If None, a default set is used. Defaults to None.
            train_ratio (float, optional): percentage of train samples. Defaults to 0.8.
            save_splits (str, optional): where to save the extracted data. Defaults to 'data'.
            seed (int, optional): seed for randomly splitting train/test. Defaults to 123456.
            train_test_extractor (bool, optional): whether to use the same extractor for train and test. Should be False to ensure there is no leak from train set to test set. Defaults to True.
        """
        self.data_path = data_path
        self.feature_extractor = FeatureExtractor(feature_extractors)
        self.save_splits=save_splits
        self.train_ratio = train_ratio
        self.seed = seed

        y = []
        filenames = []

        if extra_malware is not None and len(extra_malware) > 0:
            # get extra PE files
            extra_labels = []
            for d in extra_malware:
                for f in glob.glob(f"{d}/**/*", recursive=True):
                    if os.path.isfile(f):
                        filenames.append(f)
                        extra_labels.append(1)
            y.append(np.asarray(extra_labels))

        if extra_benign is not None and len(extra_benign) > 0:
            # get extra PE files
            extra_labels = []
            for d in extra_benign:
                for f in glob.glob(f"{d}/**/*", recursive=True):
                    if os.path.isfile(f):
                        filenames.append(f)
                        extra_labels.append(0)
            y.append(np.asarray(extra_labels))
            
        # get windows system files
        if use_windows:
            print("Searching for windows system files...")
            system_files = glob.glob('/mnt/c/Windows/system32/**/*.exe', recursive=True) \
            + glob.glob('/mnt/c/Windows/system32/**/*.dll', recursive=True) \
            + glob.glob('/mnt/c/Program Files/**/*.exe', recursive=True) \
            + glob.glob('/mnt/c/Program Files/**/*.dll', recursive=True)
            y.append(np.zeros(len(system_files)))
            filenames.extend(system_files)

        # get files from ProgramFiles
        if use_programs:
            print("Searching in program files files...")
            program_files = glob.glob('/mnt/c/Program Files/**/*.exe', recursive=True) \
            + glob.glob('/mnt/c/Program Files/**/*.dll', recursive=True) \
            + glob.glob('/mnt/c/Program Files (x86)/**/*.exe', recursive=True) \
            + glob.glob('/mnt/c/Program Files (x86)/**/*.dll', recursive=True) \
            + glob.glob('/mnt/c/Drivers/**/*.exe', recursive=True) \
            + glob.glob('/mnt/c/Drivers/**/*.dll', recursive=True)
            y.append(np.zeros(len(program_files)))
            filenames.extend(program_files)
        
        if data_path is not None:
            # load labels
            benign_labels = pd.read_csv(os.path.join(data_path, "labels", "benign.csv"))
            malware_labels = pd.read_csv(os.path.join(data_path, "labels", "malware.csv"))
            
            # label as malware or benign and concat
            benign_labels['malware'] = 0
            malware_labels['malware'] = 1
            labels = pd.concat([benign_labels, malware_labels], axis=0, ignore_index=True)

            # keep only PE files
            labels = labels[labels.type == 0]
            labels.drop('type', axis=1, inplace=True)
            # set hash as index
            labels.set_index('hash', inplace=True)

            # ignore all labels except whether it is malware
            y.append(labels.malware.to_numpy())
            # get filenames from dataset and benign files from system
            filenames.extend([os.path.join(self.data_path, 'files', 'malware' if k[1].malware else 'benign', f"{k[0]}.exe") for k in labels.iterrows()])

        # concatenate all labels
        y = np.concatenate(y, axis=0)
        filenames = np.asarray(filenames)

        if train_test_extractor:
            print("Extracting features...")
            x, unparsed = self.feature_extractor(filenames, train=True, y=y)
            y = y[~np.isin(np.arange(y.shape[0]), unparsed)]
            save_pickle((x,y,unparsed), 'tmp.pkl')

            # split train and test
            splits, splits_idx = split_arrays([y], [self.train_ratio, 1-self.train_ratio], seed=self.seed, return_idx=True)
            self.y_train, self.y_test = [k for k in splits]
            self.x_train, self.x_test = [[k[spl] for k in x] for spl in splits_idx]
        else:
            # split train and test
            splits, splits_idx = split_arrays([y], [self.train_ratio, 1-self.train_ratio], seed=self.seed, return_idx=True)
            self.y_train, self.y_test = [k[0] for k in splits]

            # extract features, remove unparsed, and save to make to save computation
            print("Extracting features...")
            self.x_train, unparsed = self.feature_extractor(filenames[splits_idx[0]], train=True, y=self.y_train)
            self.y_train = self.y_train[~np.isin(np.arange(self.y_train.shape[0]), unparsed)]
            self.x_test, unparsed = self.feature_extractor(filenames[splits_idx[1]], train=False)
            self.y_test = self.y_test[~np.isin(np.arange(self.y_test.shape[0]), unparsed)]

        ## save x,y
        self._save()
        
    def _save(self):
        names = ['train', 'test']
        # save feature extractor
        save_pickle(self.feature_extractor, f"{self.save_splits}_feature_extractor.pkl")

        datasets = []
        for d, name in zip([(self.x_train, self.y_train), (self.x_test, self.y_test)], names):
            if self.save_splits is not None:
                save_pickle(d, f"{self.save_splits}_{name}.pkl")
            datasets.append(d)

            # _, counts = np.unique(d[1], return_counts=True)
            # ratio = counts / counts.sum()
            # print(f"{name}:: Benign: {counts[0]}/{ratio[0]}%    Malware: {counts[1]}/{ratio[1]}%")

        return datasets


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-s', '--save', type=str, default='data', help='Saving directory')
    parser.add_argument('--dike', action='store_true')
    parser.add_argument('--windows', action='store_true')
    parser.add_argument('--programs', action='store_true')
    parser.add_argument('--malware', type=str, nargs='+', default=[])
    parser.add_argument('--benign', type=str, nargs='+', default=[])
    parser.add_argument('--train_ratio', type=float, default=0.8)
    parser.add_argument('--combined', action='store_true')
    args = parser.parse_args()

    dataset = DikePEDataset(
        data_path = 'data/DikeDataset' if args.dike else None,
        use_windows = args.windows,
        use_programs = args.programs,
        extra_malware = args.malware,
        extra_benign = args.benign,
        train_ratio=args.train_ratio,
        save_splits=args.save,
        train_test_extractor=args.combined,
    )
