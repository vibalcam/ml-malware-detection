from typing import Any, List
from sklearn.metrics import confusion_matrix, matthews_corrcoef
import numpy as np
from models.utils import save_pickle, load_pickle

from models.feature_extractor import FeatureExtractor


def find_best_score(y_true, y_pred, metric=matthews_corrcoef, max_fpr = 0.01, min_tpr=0.95):
    best_score = 0
    for k in np.linspace(1, 10, 101)/100:
        score = competition_scorer(y_true, y_pred, k, metric, max_fpr, min_tpr)
        best_score = max(best_score, score)

    return best_score


def competition_scorer(y_true, y_pred, threshold, metric=matthews_corrcoef, max_fpr = 0.01, min_tpr=0.95):
    y_pred = (y_pred>=threshold).astype(int)
    tn, fp, fn, tp = confusion_matrix(y_true, y_pred).ravel()
    mcc = metric(y_true=y_true, y_pred=y_pred)
    fpr = fp / (fp + tn)
    tpr = tp / (tp + fn)
    if fpr > max_fpr or tpr < min_tpr:
        return 0.0
    else:
        return mcc


class Model:
    def __init__(self, feature_extractor) -> None:
        self.feature_extractor = feature_extractor
        self.best_threshold = 0.5

    def __call__(self, x, *args: Any, **kwds: Any) -> np.array:
        raise NotImplementedError()

    def extract_features(self, pe_files: List[str]):
        return self.feature_extractor(pe_files, train=False)
        
    def predict(self, x):
        p = self.predict_proba(x)
        return (p >= self.best_threshold).astype(int)
    
    def predict_proba(self, x):
        return self(x)
    
    def evaluate(self, x, y):
        y_pred = self.predict(x)
        tn, fp, fn, tp = confusion_matrix(y_true=y, y_pred=y_pred).ravel()
        mcc = matthews_corrcoef(y_true=y, y_pred=y_pred)
        fpr = fp / (fp + tn)
        tpr = tp / (tp + fn)

        self.last_evaluation = mcc, fpr, tpr
        return self.last_evaluation
    
    def save(self, path):
        save_pickle(self, path)
    
    @staticmethod
    def load(path):
        return load_pickle(path)

    
    # def _extract_features(self,data):
    #     # initialize features with numerical ones
    #     # features = data[self.NUMERICAL_ATTRIBUTES].values.tolist()
    #     features = sparse.csr_matrix(data[self.NUMERICAL_ATTRIBUTES].values)

    #     print("Getting categorical features...", flush=True)
    #     # transform categorical data
    #     cat_features = self._transform_categorical_attributes(data[self.CATEGORICAL_ATTRIBUTES])
    #     # append categorical_features to features
    #     # features = self._append_features(features, cat_features)
    #     features = sparse.hstack((features, cat_features))

    #     print("Getting textual features...", flush=True)
    #     # transform textual data
    #     tex_features = self._transform_textual_attributes(data[self.TEXTUAL_ATTRIBUTES])
    #     # append textual_features to features
    #     # features = self._append_features(features, tex_features)
    #     features = sparse.hstack((features, tex_features))
    #     # transform in sparse matrix
    #     # features = csr_matrix(features)

    #     print("Normalizing features...", flush=True)
    #     # transform features
    #     features = self._transform_feature_scaler(features)

    #     # return features
    #     return(features)

    # def predict(self,test_data):
    #     # extract features
    #     test_features = self._extract_features(test_data)        

    #     print("Predicting classes...", flush=True)
    #     # predict features
    #     return self.classifier.predict(test_features)

    # def predict_proba(self,test_data):
    #     # extract features
    #     test_features = self._extract_features(test_data)        

    #     print("Predicting classes (proba)...", flush=True)
    #     # predict features
    #     return self.classifier.predict_proba(test_features)

    # def predict_threshold(self,test_data, threshold=0.8):
    #     # extract features
    #     test_features = self._extract_features(test_data)        

    #     print("Predicting classes (threshold = {})...".format(threshold), flush=True)
    #     # predict features
    #     prob = self.classifier.predict_proba(test_features)
    #     # initialize pred
    #     pred = []
    #     # iterate over probabilities
    #     for p in prob:
    #         # add prediction
    #         pred.append(int(p[0] < threshold))
    #     # return prediction
    #     return pred
